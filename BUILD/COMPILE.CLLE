/******************************************************************************/
/*                                                                            */
/*  @SRCLIB  - библиотека, где расположены файлы исходного кода;              */
/*  @DSTLIB  - библиотека, куда будут помещены собранные объекты.             */
/*                                                                            */
/******************************************************************************/

PGM PARM(&@SRCLIB &@DSTLIB)

  /* ВХОДНЫЕ ПАРАМЕТРЫ ********************************************************/
  DCL        VAR(&@SRCLIB)    TYPE(*CHAR) LEN(10)
  DCL        VAR(&@DSTLIB)    TYPE(*CHAR) LEN(10)



  /* ВНУТРЕННИЕ ПЕРЕМЕННЫЕ ****************************************************/
  DCL        VAR(&TAG)        TYPE(*LGL)           VALUE('0')
  DCL        VAR(&SRCLIB)     TYPE(*CHAR) LEN(10)  VALUE(CSNSRC)                /* Библиотека с файлом исходного кода */
  DCL        VAR(&DSTLIB)     TYPE(*CHAR) LEN(10)  VALUE(TMKMAKE)               /* Библиотека для размещения собранных объектов */
  DCL        VAR(&TMPLIB)     TYPE(*CHAR) LEN(10)  VALUE(QTEMP)                 /* Временная библиотека */
  DCL        VAR(&DBGMOD)     TYPE(*CHAR) LEN(10)  VALUE(*ALL)                  /* Режим отладки */
  DCL        VAR(&DEFINE)     TYPE(*CHAR) LEN(80)  VALUE(' ')                   /* Макросы компиляции */
  DCL        VAR(&OPTMOD)     TYPE(*INT)  LEN(2)                                /* Уровень оптимизации */
  DCL        VAR(&LOWKEY)     TYPE(*CHAR) LEN(4)
  DCL        VAR(&MSGKEY)     TYPE(*CHAR) LEN(4)
  DCL        VAR(&HIKEY)      TYPE(*CHAR) LEN(4)
  DCL        VAR(&MSG)        TYPE(*CHAR) LEN(132)
  DCL        VAR(&MSGID)      TYPE(*CHAR) LEN(7)
  DCL        VAR(&I)          TYPE(*INT)  LEN(2)
  DCL        VAR(&SEV)        TYPE(*DEC)  LEN(2)
  DCL        VAR(&RTNTYPE)    TYPE(*CHAR) LEN(2)
  DCL        VAR(&SIGN)       TYPE(*CHAR) LEN(1)

  CALLSUBR   INITIALIZE                                                         /* Инициализация переменных */




  /* ОЧИСТКА ******************************************************************/
  DLTCMD     CMD(&DSTLIB/TMKMAKE)
  MONMSG     MSGID(CPF0000)
  DLTPGM     PGM(&DSTLIB/TMKMAKE)
  MONMSG     MSGID(CPF0000)
  DLTMSGF    MSGF(&DSTLIB/TMKMSGF)
  MONMSG     MSGID(CPF0000)
  DLTF       FILE(&DSTLIB/CMDDEFS)
  MONMSG     MSGID(CPF0000)
  DLTF       FILE(&DSTLIB/DEBUG)
  MONMSG     MSGID(CPF0000)
  DLTF       FILE(&DSTLIB/QMAKSRC)
  MONMSG     MSGID(CPF0000)





  /* СОЗДАНИЕ ФАЙЛА ВСТРОЕННЫХ МАКРОСОВ ***************************************/
  CHGLIBL    LIBL(*NONE)
  SNDPGMMSG  MSG('BEGIN MONITORING') KEYVAR(&LOWKEY)

  CRTSRCPF   FILE(&DSTLIB/QMAKSRC) RCDLEN(240) TEXT('Make tool built-in')
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADBUILTIN)

  CPYSRCF    FROMFILE(&SRCLIB/TMKMAKE) FROMMBR(BUILTINMF) +
             TOFILE(&DSTLIB/QMAKSRC) TOMBR(BUILTIN)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADBUILTIN)




  /* КОПИРОВАНИЕ ОТЛАДОЧНОГО ФАЙЛА ********************************************/
  IF (&DBGMOD = *ALL) DO
    CPYF       FROMFILE(&SRCLIB/DEBUG) TOFILE(&DSTLIB/DEBUG) +
               FROMMBR(*ALL) TOMBR(*FROMMBR) CRTFILE(*YES)
    MONMSG     MSGID(CPF0000) EXEC(GOTO BADBUILTIN)
  ENDDO




  /* СОЗДАНИЕ И ЗАПОЛНЕНИЕ ФАЙЛА ОПИСАНИЯ КОМАНД ******************************/
  CRTPF      FILE(&DSTLIB/CMDDEFS) SRCFILE(&SRCLIB/TMKMAKE) +
             OPTION(*EVENTF *NOSRC *NOLIST) SIZE(*NOMAX) +
             WAITFILE(*IMMED) LVLCHK(*NO)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADCMDF)

  SNDPGMMSG  MSG('BEGIN MONITORING') KEYVAR(&LOWKEY)
  RUNSQL     SQL('insert into ' *CAT &DSTLIB *CAT '/CMDDEFS +
                  (CMDNAME) values +
                  (''CRTPGM'') ') +
             COMMIT(*NONE)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADCMDF)




  /* СОЗДАНИЕ И ЗАПОЛНЕНИЕ ФАЙЛА СООБЩЕНИЙ ************************************/
  CHGLIBL    LIBL(*NONE)
  SNDPGMMSG  MSG('BEGIN MONITORING') KEYVAR(&LOWKEY)

  CRTMSGF    MSGF(&DSTLIB/TMKMSGF) TEXT('Make tool messages')
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADMSGF)

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0001) MSG('Start Make Tool')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0002) MSG('Target Labels')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0003) MSG('Description File')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0004) MSG('Make Library')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0005) MSG('File Member')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0006) MSG('Macro Definitions')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0007) MSG('Options')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0008) MSG('Source Margin')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0009) MSG('Left Margin')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0010) MSG('Right Margin')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0011) MSG('Return Code Handling')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0012) MSG('Severity')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0013) MSG('User Message Log')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0014) MSG('Method')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             MSGID(TMK0015) MSG('Internal Service Options')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9001) +
             MSG('Invalid inference rule specification in line &1.') +
             SECLVL('&N Cause . . . . . :   The inference rule specified in line &1 does not conform to the +
                     specification. Possibly dependents are specified in the definition. &N Recovery  . . . +
                     :   Correct the invalid rule in the description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9002) +
             MSG('Invalid .SUFFIXES dependents specification in line &1.') +
             SECLVL('&N Cause . . . . . :   The dependents for the .SUFFIXES rule in the description file do +
                     not contain valid object specifications. Possibly missing thg e ''.'' character in +
                     front of the dependent name. &N Recovery  . . . :   Correct the invalid object name in +
                     the description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9003) +
             MSG('Nested include directive exceeded the maximum (32) allowed in line &1.') +
             SECLVL('&N Recovery  . . . :   Correct the description file include directive nesting structure +
                     and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9004) +
             MSG('Macro parenthesis mismatched in line &1.') +
             SECLVL('&N Cause . . . . . :   An apparent macro reference was found, but the closing parenthesis +
                     are missing. &N Recovery  . . . :   Verify the parenthesis for macro references are +
                     correct and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5) (*CHAR 32)) MSGID(TMK9005) +
             MSG('Do not know how to process target &2 in line &1.') +
             SECLVL('&N Cause . . . . . :   The specified target in the description file needs to be processed, +
                     but neither an explicit rule or an inference rule provide sufficient information for +
                     TMKMAKE to proceed. &N Recovery  . . . :   Verify the rules in the description file is +
                     correct and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 1000)) MSGID(TMK9006) +
             MSG('&1') +
             SECLVL('&N Cause . . . . . :   User message. &N Recovery  . . . :   None.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 34)) MSGID(TMK9007) +
             MSG('Invalid macro definition in TMKMAKE command, ''='' character expected.') +
             SECLVL('&N Cause . . . . . :   The MACRO &1 defined in the TMKMAKE command does not contains a valid +
                     macro definition; the ''='' character is missing in the macro definition. +
                     &N Recovery  . . . :   Retry the TMKMAKE command with the proper macro definition syntax')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9008) +
             MSG('Multiple rules defined for the same target in line &1.') +
             SECLVL('&N Cause . . . . . :   More than one rules with commands sequence are defined using the same +
                     target. &N Recovery  . . . :   Correct the invalid rule in the description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5) (*CHAR 32)) MSGID(TMK9009) +
             MSG('Unable to open include file &2 in line &1.') +
             SECLVL('&N Cause . . . . . :   The inference rule specified in line &1 does not conform to the +
                     specification. &N Recovery  . . . :   Correct the invalid rule in the description file and +
                     try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9010) +
             MSG('Invalid desription rule in line &1.') +
             SECLVL('&N Cause . . . . . :   The specified text line in the description file does not conform to +
                     the syntax of a dependency rule for the TMKMAKE command. &N Recovery  . . . :   Correct the +
                     invalid rule in the description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 50)) MSGID(TMK9011) +
             MSG('Run out of heap space.') +
             SECLVL('&N Cause . . . . . :   The TMKMAKE command was trying to allocate storage from the program +
                     heap at location &1 and was unsuccessful. &N Recovery  . . . :   Decrease the complexity of +
                     the description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 32)) MSGID(TMK9012) +
             MSG('Unable to open description file &1.') +
             SECLVL('&N Cause . . . . . :   TMKMAKE command was unable to open the description file as specified +
                     in the command. &N Recovery  . . . :   Make sure the description file exists in the specified +
                     location and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             MSGID(TMK9013) +
             MSG('Invalid MARGIN specification in the TMKMAKE command, parameters ignored.') +
             SECLVL('&N Cause . . . . . :   The MARGIN parameters in the TMKMAKE command are invalid. +
                     &N Recovery  . . . :   None.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 32)) MSGID(TMK9014) +
             MSG('Target &1 not found in description file.') +
             SECLVL('&N Cause . . . . . :   Target(s) specified in the TMKMAKE command can not be found in the +
                     description file. &N Recovery  . . . :   Correct the target name(s) in the command and +
                     try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             MSGID(TMK9015) +
             MSG('Default built-in rule file BUILTIN.QMAKSRC not found.') +
             SECLVL('&N Cause . . . . . :   Built-in inference rule file, BUILTIN.QMAKSRC, was not found in +
                     *CURLIB or *LIBL, no built-in rules are applied to the current TMKMAKE command processing. +
                     &N Recovery  . . . :   None.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 1024)) MSGID(TMK9016) +
             MSG('Error directive: &1') +
             SECLVL('&N Cause . . . . . :   The TMKMAKE command is terminated by a user requested error directive +
                     in the description file. &N Recovery  . . . :   None.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9017) +
             MSG('No expression in if or elif directives in line &1.') +
             SECLVL('&N Cause . . . . . :   An if or elif directive was found, but an invalid or no expression was +
                     found after the if or elif keyword. &N Recovery  . . . :   Correct the invalid directive +
                     expression in the description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5) (*CHAR 32)) MSGID(TMK9018) +
             MSG('Unknown directive &2 in line &1.') +
             SECLVL('&N Cause . . . . . :   The specified directive was found in the description file, but it is not +
                     recognized by the TMKMAKE command. &N Recovery  . . . :   Remove the invalid directive from the +
                     description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9019) +
             MSG('Divided by zero in the if directive expression in line &1.') +
             SECLVL('&N Cause . . . . . :   As stated. &N Recovery  . . . :   Correct the invalid expression in the +
                     description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9020) +
             MSG('Syntax error found in if directive expression in line &1.') +
             SECLVL('&N Cause . . . . . :   The expression in the if directive does not contain an valid arithmetic +
                     expression. &N Recovery  . . . :   Correct the invalid expression in the description file and +
                     try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9021) +
             MSG('The command in line &1 exceeds the 3000 characters limit.') +
             SECLVL('&N Cause . . . . . :   The size of the command specified in the description file which the +
                     TMKMAKE command needs to process, after all the macro substitution, exceeds the limit set by +
                     QCMDEXC. &N Recovery  . . . :   Make sure the command needs to be processed in the description +
                     file is less than 3000 characters.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9022) +
             MSG('Invalid octal number in conditional directive expression in line &1.') +
             SECLVL('&N Cause . . . . . :   As stated. &N Recovery  . . . :   Correct the invalid expression in the +
                     description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9023) +
             MSG('Invalid hexadecimal number in conditional directive expression in line &1.') +
             SECLVL('&N Cause . . . . . :   As stated. &N Recovery  . . . :   Correct the invalid expression in the +
                     description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9024) +
             MSG('Conditional directive expression too complicated in line &1.') +
             SECLVL('&N Cause . . . . . :   As stated. &N Recovery  . . . :   Reduce the complexity of the expression +
                     in the description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9025) +
             MSG('Internal conditional directive expression error in line &1.') +
             SECLVL('&N Cause . . . . . :   Problems were detected by the TMKMAKE command when trying to evaluate an +
                     expression in the if or elif directives. &N Recovery  . . . :   Reduce the complexity of the +
                     expression in the description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9026) +
             MSG('Invalid characters in conditional directive expression in line &1.') +
             SECLVL('&N Cause . . . . . :   Invalid characters, such as non numeric character and operators which are +
                     not supported by the TMKMAKE command, are found in the conditional directive expression. +
                     &N Recovery  . . . :   Correct the invalid expression in the description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9027) +
             MSG('Macro expansion exceeds 3000 characters limit in line &1.') +
             SECLVL('&N Cause . . . . . :   Macro expression exceeds the 3000 character limit. +
                     &N Recovery  . . . :   Make sure any macro expansion does not exceed the 3000 characters limit.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9028) +
             MSG('Misplaced elif directive in line &1.') +
             SECLVL('&N Cause . . . . . :   The elif directive was found in the description file where it was +
                     not expected. &N Recovery  . . . :   Correct the misplaced elif directive in the description +
                     file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9029) +
             MSG('Misplaced else directive in line &1.') +
             SECLVL('&N Cause . . . . . :   The else directive was found in the description file where it was not +
                     expected. &N Recovery  . . . :   Correct the misplaced else directive in the description file +
                     and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9030) +
             MSG('Misplaced endif directive in line &1.') +
             SECLVL('&N Cause . . . . . :   The endif directive was found in the description file where it was not +
                     expected. &N Recovery  . . . :   Correct the misplaced endif directive in the description file +
                     and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             MSGID(TMK9031) +
             MSG('Unexpected end of file encountered.') +
             SECLVL('&N Cause . . . . . :   The end of the description file was encountered when the TMKMAKE command +
                     expected more input. &N Recovery  . . . :   Make sure all rules in the description file are of +
                     valid syntax and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9032) +
             MSG('Invalid command syntax in line &1; rejected by QCMDEXC.') +
             SECLVL('&N Cause . . . . . :   The command text passed to QCMDEXC was rejected due to invalid command +
                     syntax. &N Recovery  . . . :   Correct the invalid command sequences in the description file +
                     and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9033) +
             MSG('Command executed by TMKMAKE failed in line &1.') +
             SECLVL('&N Cause . . . . . :   Either an exception has occurred or the return code returned by the +
                     command executed by TMKMAKE exceeds the severity level set by the TMKMAKE command. +
                     &N Recovery  . . . :   Check the description file and make sure the command being executed is +
                     correct and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5) (*CHAR 22)) MSGID(TMK9034) +
             MSG('Number of members in file &2 exceeds the limit.') +
             SECLVL('&N Cause . . . . . :   *ALL is specified in the SRCMBR field in the STRMAKE command and there +
                     are more members in the source file than the QUSLMBR program can handled. The number of members +
                     processed is limited to &1. &N Recovery  . . . :   Check the source file and make sure the +
                     number of members in file &2 does not exceed &1.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 22)) MSGID(TMK9035) +
             MSG('No member in file &1 is found.') +
             SECLVL('&N Cause . . . . . :   *ALL is specified in the SRCMBR field in the STRMAKE command and no +
                     member is found in the source file. &N Recovery  . . . :   Check the source file and make sure +
                     there is at least one member in the file.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5) (*CHAR 9)) MSGID(TMK9036) +
             MSG('Invalid format for keyword &2 in line &1.') +
             SECLVL('&N Cause . . . . . :   Keyword &2 with invalid format was found in the description file. +
                     &N Recovery  . . . :   Keyword must either be followed by a '':'' character or no text at all. +
                     Correct the syntax of the keyword &2 in the description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9037) +
             MSG('Invalid inference rule format in line &1.') +
             SECLVL('&N Cause . . . . . :   Invalid inference rule format is found in the description file. Possibly +
                     missing '':'' character in the rule definition. Correct the error and try again. +
                     &N Recovery  . . . :   Correct the inference rule format and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9038) +
             MSG('Invalid inference rule format, no target found in line &1.') +
             SECLVL('&N Cause . . . . . :   Invalid inference rule format is found in the description file and no +
                     target can be identified. Correct the error and try again. &N Recovery  . . . :   Correct the +
                     inference rule format and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9039) +
             MSG('Command sequence is found with no associated target definition in line &1.') +
             SECLVL('&N Cause . . . . . :   Command sequence with no associated target definition is found in the +
                     description. &N Recovery  . . . :   Correct the inference rule by adding a target definition +
                     in the rule and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9040) +
             MSG('Invalid object specification found in line &1.') +
             SECLVL('&N Cause . . . . . :   An invalid object specification is found in the description file. +
                     &N Recovery  . . . :   Correct the invalid object specification and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5) (*CHAR 9)) MSGID(TMK9041) +
             MSG('Unknown keyword &2 in line &1.') +
             SECLVL('&N Cause . . . . . :   "&2" is an unsupported keyword starting with a ''.'' character. +
                     &N Recovery  . . . :   Correct the syntax of the keyword &2 in the descriptin file and try +
                     again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5) (*CHAR 32)) MSGID(TMK9042) +
             MSG('TMKMAKE has detected recursive processing for ''&2'' in line &1.') +
             SECLVL('&N Cause . . . . . :   The specified target in the description file is processed recursively +
                     according to the rule defined. &N Recovery  . . . :   Verigy the rule in the description file +
                     is correct and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5) (*CHAR 32)) MSGID(TMK9043) +
             MSG('''&2'' is up-to-date in line &1.') +
             SECLVL('&N Cause . . . . . :   The specified target has been processed by TMKMAKE and is now up-to-date. +
                     &N Recovery  . . . :   None.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9044) +
             MSG('Invalid ''-'' prefix severity limit specification in line &1.') +
             SECLVL('&N Cause . . . . . :   The specified severity limit for the ''-'' prefix does not conform to +
                     specification.  There must have at least 1 blank character after the severity limit. +
                     &N Recovery  . . . :   Correct the description file and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5) (*CHAR 34)) MSGID(TMK9045) +
             MSG('Macro &2 in line &1 can not be undefined.') +
             SECLVL('&N Cause . . . . . :   The macro &2 was not previously defined. &N Recovery  . . . :   +
                     Define the macro &2 and try again.')

  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9046) +
             MSG('Nested conditional directives exceeded the maximum allowed in line &1.') +
             SECLVL('&N Recovery  . . . :   Correct the description file conditional directive nesting structure +
                     and try again.')


  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 5)) MSGID(TMK9047) +
             MSG('Invalid macro syntax in line &1.') +
             SECLVL('&N Cause . . . . . :   An invalid macro syntax was found in &1.  Probably missing ''='' +
                     character in output translation macro format. &N Recovery  . . . :   Correct the invalid macro +
                     syntax and try again.')


  ADDMSGD    MSGF(&DSTLIB/TMKMSGF) LVL(*CURRENT 01) DMPLST(*NONE) +
             SEV(00) LOGPRB(*NO) ALROPT(*NO) +
             FMT((*CHAR 1000)) MSGID(TMK9048) +
             MSG('Wrong number of parameters') +
             SECLVL('&N Cause . . . . . :   Incorrect number of parameters passed to the program. +
                     &N Recovery  . . . :   Run the program using the TMKMAKE command.')




  /* КОМПИЛЯЦИЯ МОДУЛЕЙ *******************************************************/
  CHGLIBL    LIBL(*NONE)

  CRTCMOD    MODULE(&TMPLIB/MAIN) SRCFILE(&SRCLIB/TMKMAKE) SRCMBR(MAIN$) +
             DBGVIEW(&DBGMOD) DEFINE(&DEFINE) OPTIMIZE(&OPTMOD) +
             OPTION(*EVENTF) PFROPT(*STRDONLY) +
             CHECKOUT(*COND *PARM *REACH *UNUSED)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADMOD)

  CRTCMOD    MODULE(&TMPLIB/MFPROC) SRCFILE(&SRCLIB/TMKMAKE) SRCMBR(MFPROC$) +
             DBGVIEW(&DBGMOD) DEFINE(&DEFINE) OPTIMIZE(&OPTMOD) +
             OPTION(*EVENTF) PFROPT(*STRDONLY) +
             CHECKOUT(*COND *PARM *REACH *UNUSED)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADMOD)

  CRTCMOD    MODULE(&TMPLIB/PARSER) SRCFILE(&SRCLIB/TMKMAKE) SRCMBR(PARSER$) +
             DBGVIEW(&DBGMOD) DEFINE(&DEFINE) OPTIMIZE(&OPTMOD) +
             OPTION(*EVENTF) PFROPT(*STRDONLY) +
             CHECKOUT(*COND *PARM *REACH *UNUSED)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADMOD)

  CRTCMOD    MODULE(&TMPLIB/FILE) SRCFILE(&SRCLIB/TMKMAKE) SRCMBR(FILE$) +
             DBGVIEW(&DBGMOD) DEFINE(&DEFINE) OPTIMIZE(&OPTMOD) +
             OPTION(*EVENTF) PFROPT(*STRDONLY) +
             CHECKOUT(*COND *PARM *REACH *UNUSED)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADMOD)

  CRTCMOD    MODULE(&TMPLIB/BUILTIN) SRCFILE(&SRCLIB/TMKMAKE) SRCMBR(BUILTIN$) +
             DBGVIEW(&DBGMOD) DEFINE(&DEFINE) OPTIMIZE(&OPTMOD) +
             OPTION(*EVENTF) PFROPT(*STRDONLY) +
             CHECKOUT(*COND *PARM *REACH *UNUSED)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADMOD)

  CRTCMOD    MODULE(&TMPLIB/MSGHANDLE) SRCFILE(&SRCLIB/TMKMAKE) SRCMBR(MSGHANDLE$) +
             DBGVIEW(&DBGMOD) DEFINE(&DEFINE) OPTIMIZE(&OPTMOD) +
             OPTION(*EVENTF) PFROPT(*STRDONLY) +
             CHECKOUT(*COND *PARM *REACH *UNUSED)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADMOD)

  CRTCMOD    MODULE(&TMPLIB/DICTION) SRCFILE(&SRCLIB/TMKMAKE) SRCMBR(DICTION$) +
             DBGVIEW(&DBGMOD) DEFINE(&DEFINE) OPTIMIZE(&OPTMOD) +
             OPTION(*EVENTF) PFROPT(*STRDONLY) +
             CHECKOUT(*COND *PARM *REACH *UNUSED)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADMOD)

  CRTCMOD    MODULE(&TMPLIB/OPTION) SRCFILE(&SRCLIB/TMKMAKE) SRCMBR(OPTION$) +
             DBGVIEW(&DBGMOD) DEFINE(&DEFINE) OPTIMIZE(&OPTMOD) +
             OPTION(*EVENTF) PFROPT(*STRDONLY) +
             CHECKOUT(*COND *PARM *REACH *UNUSED)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADMOD)

  CRTCMOD    MODULE(&TMPLIB/UTILITY) SRCFILE(&SRCLIB/TMKMAKE) SRCMBR(UTILITY$) +
             DBGVIEW(&DBGMOD) DEFINE(&DEFINE) OPTIMIZE(&OPTMOD) +
             OPTION(*EVENTF) PFROPT(*STRDONLY) +
             CHECKOUT(*COND *PARM *REACH *UNUSED)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADMOD)

  CRTCMOD    MODULE(&TMPLIB/EXPR) SRCFILE(&SRCLIB/TMKMAKE) SRCMBR(EXPR$) +
             DBGVIEW(&DBGMOD) DEFINE(&DEFINE) OPTIMIZE(&OPTMOD) +
             OPTION(*EVENTF) PFROPT(*STRDONLY) +
             CHECKOUT(*COND *PARM *REACH *UNUSED)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADMOD)

  CRTCPPMOD  MODULE(&TMPLIB/EVENTF) SRCFILE(&SRCLIB/TMKMAKE) SRCMBR(EVENTF$) +
             DBGVIEW(&DBGMOD) OPTIMIZE(&OPTMOD) +
             OPTION(*EVENTF) PFROPT(*STRDONLY) +
             CHECKOUT(*COND *PARM *REACH *UNUSED)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADMOD)




  /* СБОРКА ПРОГРАММ **********************************************************/
  CHGLIBL    LIBL(&TMPLIB)
  SNDPGMMSG  MSG('BEGIN MONITORING') KEYVAR(&LOWKEY)

  CRTPGM     PGM(&DSTLIB/TMKMAKE) +
             MODULE(MAIN MFPROC PARSER FILE BUILTIN MSGHANDLE +
                    DICTION OPTION UTILITY EXPR EVENTF)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADBUILD)




  /* СБОРКА КОМАНД ************************************************************/
  CHGLIBL    LIBL(&TMPLIB)
  SNDPGMMSG  MSG('BEGIN MONITORING') KEYVAR(&LOWKEY)

  CRTCMD     CMD(&DSTLIB/TMKMAKE) PGM(&DSTLIB/TMKMAKE) +
             SRCFILE(&SRCLIB/TMKMAKE) PMTFILE(&DSTLIB/TMKMSGF) +
             OPTION(*EVENTF)
  MONMSG     MSGID(CPF0000) EXEC(GOTO BADBUILD)




  /* ТОЧКИ ВЫХОДА *************************************************************/
  GOOD:                                                                         /* Все объекты собраны успешно */
  SNDPGMMSG  MSG('BEGIN MONITORING') KEYVAR(&LOWKEY)
  SNDPGMMSG  MSGID(CPA2401) MSGF(QCPFMSG) MSGTYPE(*INFO) +
             MSGDTA('Done successful!')
  GOTO       FINALLY

  BADBUILTIN:                                                                   /* Не удалось создать файл встроенных макросов */
  SNDPGMMSG  MSGID(CPA2401) MSGF(QCPFMSG) MSGTYPE(*DIAG) +
             MSGDTA('Built-in file create failed...')
  GOTO       FINALLY

  BADCMDF:                                                                      /* Не удалось создать файл с описанием команд */
  SNDPGMMSG  MSGID(CPA2401) MSGF(QCPFMSG) MSGTYPE(*DIAG) +
             MSGDTA('Command definition file create failed...')
  GOTO       FINALLY

  BADMSGF:                                                                      /* Не удалось создать файл сообщений */
  SNDPGMMSG  MSGID(CPA2401) MSGF(QCPFMSG) MSGTYPE(*DIAG) +
             MSGDTA('Message file create failed...')
  GOTO       FINALLY

  BADMOD:                                                                       /* Не удалось выполнить компиляцию модуля */
  SNDPGMMSG  MSG('BEGIN MONITORING') KEYVAR(&LOWKEY)
  SNDPGMMSG  MSGID(CPA2401) MSGF(QCPFMSG) MSGTYPE(*DIAG) +
             MSGDTA('Module compilation failed...')
  GOTO       FINALLY

  BADBUILD:                                                                     /* Не удалось выполнить сборку программы */
  SNDPGMMSG  MSGID(CPA2401) MSGF(QCPFMSG) MSGTYPE(*DIAG) +
             MSGDTA('Program build failed...')
  GOTO       FINALLY




  /* ИЗВЛЕЧЕНИЕ СООБЩЕНИЙ ИЗ ЛОГА ЗАДАНИЯ В ФАЙЛ ОШИБОК ***********************/
  FINALLY:
  SNDPGMMSG  MSG('END MONITORING') KEYVAR(&HIKEY)

  RMVMSG     MSGKEY(&LOWKEY)
  RMVMSG     MSGKEY(&HIKEY)
  CHGVAR     VAR(%BIN(&MSGKEY 1 4)) VALUE(%BIN(&LOWKEY 1 4) + 1)

  DLTF       FILE(&TMPLIB/LOGMSG)
  MONMSG     MSGID(CPF0000)
  CRTPF      FILE(QTEMP/LOGMSG) RCDLEN(300) MAXMBRS(*NOMAX)

  RUNSQL     SQL('insert into QTEMP/LOGMSG values +
                  (''TIMESTAMP  0 20210211140117''), +
                  (''PROCESSOR  0 000 1'')') +
             COMMIT(*NONE)

  LOOP:                                                                         /* Цикл извлечения сообщений */
    RCVMSG PGMQ(*SAME (*)) MSGKEY(&MSGKEY) RMV(*NO) +
           MSG(&MSG) MSGID(&MSGID) SEV(&SEV) RTNTYPE(&RTNTYPE)
    MONMSG CPF2410 EXEC(GOTO CONTINUE)

    DOFOR &I 1 %LEN(&MSG)
      CHGVAR VAR(&I) VALUE(%SCAN('''' &MSG))
      IF (&I = 0) LEAVE
      CHGVAR VAR(%SUBSTRING(&MSG &I 1)) VALUE('"')
    ENDDO

    SELECT
      WHEN COND(&RTNTYPE = '15') THEN(CHGVAR VAR(&SIGN) VALUE('E'))
      WHEN COND(&RTNTYPE = '02') THEN(DO)
        IF (&SEV *LE 10)         THEN(CHGVAR VAR(&SIGN) VALUE('W'))
        ELSE                          CHGVAR VAR(&SIGN) VALUE('S')
      ENDDO
      OTHERWISE                   CMD(CHGVAR VAR(&SIGN) VALUE('I'))
    ENDSELECT

    RUNSQL SQL('insert into QTEMP/LOGMSG values +
                ( +
                  ''ERROR      1 001 0 000000 000000 000 000000 000 ' +
                  *CAT &MSGID *CAT ' ' *CAT &SIGN *CAT ' ' *CAT  +
                  %CHAR(&SEV) *CAT '132 ' *CAT %TRIM(&MSG) *CAT ''' +
                )') +
           COMMIT(*NONE)

    CONTINUE:
    CHGVAR VAR(%BIN(&MSGKEY 1 4)) VALUE(%BIN(&MSGKEY 1 4) + 1)
    IF (&MSGKEY *LT &HIKEY) GOTO LOOP
  ENDLOOP:



  /* ПЕРЕНОС СООБЩЕНИЙ В ФАЙЛ ОШИБОК ******************************************/
  CPYF       FROMFILE(QTEMP/LOGMSG) TOFILE(&SRCLIB/EVFEVENT) +
             FROMMBR(*ALL) TOMBR(*FROMMBR) MBROPT(*ADD) CRTFILE(*YES) +
             FMTOPT(*NOCHK)

  CPYF       FROMFILE(&DSTLIB/EVFEVENT) TOFILE(&SRCLIB/EVFEVENT) +
             FROMMBR(*ALL) TOMBR(*FROMMBR) MBROPT(*ADD) FMTOPT(*NOCHK)
  MONMSG     MSGID(CPF0000)
  DLTF       FILE(&DSTLIB/EVFEVENT)
  MONMSG     MSGID(CPF0000)

  CPYF       FROMFILE(&TMPLIB/EVFEVENT) TOFILE(&SRCLIB/EVFEVENT) +
             FROMMBR(*ALL) TOMBR(*FROMMBR) MBROPT(*ADD) FMTOPT(*NOCHK)
  MONMSG     MSGID(CPF0000)
  DLTF       FILE(&TMPLIB/EVFEVENT)
  MONMSG     MSGID(CPF0000)

  IF (&DBGMOD = *NONE) DO
    DLTF       FILE(&SRCLIB/EVFEVENT)
    MONMSG     MSGID(CPF0000)
  ENDDO



  /* ПОДПРОЦЕДУРА ИНИЦИАЛИЗАЦИИ ************************************************/
  SUBR INITIALIZE

  CHKOBJ     OBJ(QSYS/&@SRCLIB) OBJTYPE(*LIB)                                   /* Обработка входных параметров */
  MONMSG     MSGID(CPF0000) EXEC(CHGVAR VAR(&TAG) VALUE('1'))
  IF (*NOT &TAG) CHGVAR VAR(&SRCLIB) VALUE(&@SRCLIB)
  CHGVAR     VAR(&TAG) VALUE('0')

  CHKOBJ     OBJ(QSYS/&@DSTLIB) OBJTYPE(*LIB)
  MONMSG     MSGID(CPF0000) EXEC(CHGVAR VAR(&TAG) VALUE('1'))
  IF (*NOT &TAG) CHGVAR VAR(&DSTLIB) VALUE(&@DSTLIB)
  CHGVAR     VAR(&TAG) VALUE('0')

  DLTF       FILE(&SRCLIB/EVFEVENT)                                             /* Удаление файла ошибок */
  MONMSG     MSGID(CPF0000 MCH0000 RPG0000)

  DLTF       FILE(&DSTLIB/EVFEVENT)
  MONMSG     MSGID(CPF0000)

  DLTF       FILE(&TMPLIB/EVFEVENT)
  MONMSG     MSGID(CPF0000)

  IF (&DBGMOD = *ALL) DO
    CHGVAR VAR(&OPTMOD) VALUE(10)
    ENDDO
  ELSE DO
    CHGVAR VAR(&OPTMOD) VALUE(40)
  ENDDO

  CHGLIBL    LIBL(*NONE) CURLIB(*CRTDFT)                                        /* Очистка либла */

  ENDSUBR



ENDPGM
